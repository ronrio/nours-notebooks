# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_Kalman_filter.ipynb.

# %% auto 0
__all__ = ['z_state', 'x_state', 'KalmanFilter', 'EKF', 'ekf_localization']

# %% ../nbs/02_Kalman_filter.ipynb 3
import numpy as np
from .probabilistic_state_estimation import calculate_B_matrix

# Linear Kalman Filter
class KalmanFilter:
    def __init__(self, transition_matrix:np.array, # system model
                 measurment_matrix:np.array, # measurement model
                 state_estimate:np.array, # initial state
                 state_cov:np.array, # initial state covariance]
                 process_noise_cov:np.array, # process noise covariance
                 measurement_noise_cov:np.array # measurement noise covariance
                 ) -> None:
        self.A = transition_matrix
        self.H = measurment_matrix
        self.x = state_estimate
        self.P = state_cov
        self.Q = process_noise_cov
        self.R = measurement_noise_cov

    def predict(self, dk:float=1.0, # delta time
                u:np.array=np.zeros((2,)), # control inputs 2x1 Numpy Array
                w:np.array=np.zeros((3,)) # process noises, 3x1 NumPy Array
                ) -> None:
        """ 
        Predict the state estimate at time k based on the state 
        estimate at time k-1 and the control input applied at time k-1.
        """
        self.x_predicted = (self.A @ self.x) + (calculate_B_matrix(self.x[2], dk) @ u) + w
        self.P_predicted = self.A @ self.P @ self.A.T + self.Q

    def calculate_y_residual(self, z:np.array, # sensor measurement 3x1 NumPy Array
                                v:np.array # observation noise 3x1 NumPy Array
                             ) -> np.array:
        """
        Calculate the difference between the actual sensor measurements
        at time k minus what the measurement(observation) model predicted.
        the sensor measurements would be for the current timestep k.
        """
        return z - ((self.H @ self.x_predicted) + v)
    
    def calculate_residual_cov(self) -> np.array:
        return self.H @ self.P_predicted @ self.H.T + self.R

    def compute_kalman_gain(self) -> np.array: # Kalman Gain
        """
        Calculate the near-optimal Kalman gain
        We use pseudoinverse since some of the matrices might be
        non-square or singular.
        """
        # innovation covariance
        self.S = self.calculate_residual_cov()
        return self.P_predicted @ self.H.T @ np.linalg.pinv(self.S)

    def update(self, z:np.array, # sensor measurement 3x1 NumPy Array
               v:np.array=np.zeros((3, 1)) # sensor noise 3x1 NumPy Array
               ) -> None:
        """
        Update state estimate for time k.
        Update the state covariance estimate for time k.
        """
        self.y_residual = self.calculate_y_residual(z, v)
        self.K = self.compute_kalman_gain()
        x_estimated = self.x_predicted + (self.K @ self.y_residual)
        P_estimated = self.P_predicted - self.K @ self.H @ self.P_predicted
        self.x = x_estimated
        self.P = P_estimated


# %% ../nbs/02_Kalman_filter.ipynb 16
class EKF(KalmanFilter):
    def __init__(self, transition_matrix:np.array, # system model
                 measurement_matrix:np.array, # measurement model
                 state_estimate:np.array, # initial state
                 state_cov:np.array, # initial state covariance]
                 process_noise_cov:np.array, # process noise covariance
                 measurement_noise_cov:np.array, # measurement noise covariance
                 state_transition_jacobian: np.array, # Jacobian of the state transition function
                 measurement_jacobian: np.array # Jacobian of the observation function
                 ) -> None:
    
        super().__init__(transition_matrix,
                       measurement_matrix,
                       state_estimate,
                       state_cov,
                       process_noise_cov,
                       measurement_noise_cov)
        self.A_jacobian = state_transition_jacobian
        self.H_jacobian = measurement_jacobian
        
    def predict(self, dk:float=0.1, # delta time
                u:np.array=np.zeros((2,)), # The control input vector at time k-1 in the global reference frame. [v, yaw_rate]
                w:np.array=np.zeros((3,)) # process noises, 3x1 NumPy Array
                ) -> None:
        super().predict(dk, u, w)

    def update(self, z:np.array, # sensor measurement 1x3 NumPy Array
                v:np.array # sensor noise 3x1 NumPy Array
                ) -> None:
        super().update(z, v)

# %% ../nbs/02_Kalman_filter.ipynb 19
z_state = 3
x_state = 3
def ekf_localization(mu, sigma, u, zs, m, R, Q):
    '''
    EKF localization with unknown correspondences.

    Parameters
    ----------
    mu
        The current state estimate, [x y theta], 3x1 NumPy array.
    sigma
        The state covariance, 3x3 NumPy array.
    u
        The delta motion, 3x1 Numpy array.
    zs
        Observed features, Nx3 Numpy array of N observations and [r phi s], namely range, bearing and signature.
    m
        Landmark points, Mx3 Numpy array of M landmarks. [x y s] 2D position and signature.
    R
        Process noise, 3x1 NumPy array, [sigma_x, sigma_y, sigma_theta].
    Q
        Observation noise, 3x1 NumPy array, [sigma_r sigma_phi sigma_s].

    Returns
    -------
    mu_updated
        The updated state.
    sigma_updated
        The updated state covariance.
    '''
    # Predict
    mu_predicted = mu + u
    sigma_predicted = sigma + np.eye(x_state) @ R
    n_map_points = len(m)

    # Initialize variables for storing Jacobians and expected observations
    H = [np.zeros((z_state, x_state)) for map_idx in range(n_map_points)]
    z_expected = [np.zeros((z_state,)) for map_idx in range(n_map_points)]
    psi = [np.zeros((z_state, z_state)) for map_idx in range(n_map_points)]

    x_predicted = mu_predicted[0]
    y_predicted = mu_predicted[1]
    theta_predicted = mu_predicted[2]

    for k, landmark in enumerate(m):
        m_kx = landmark[0]
        m_ky = landmark[1]
        m_ks = landmark[2]
        delta_k = np.array([m_kx - x_predicted, m_ky - y_predicted]) # x, y difference between the map point k, and predicted state.
        delta_kx = delta_k[0]
        delta_ky = delta_k[1]
        q_k = delta_k.T @ delta_k # distance squared

        z_expected[k] = np.array([np.sqrt(q_k), np.arctan2(delta_ky, delta_kx) - theta_predicted, m_ks])
        H[k] = 1 / q_k * np.array([
            [np.sqrt(q_k)* delta_kx, -np.sqrt(q_k)* delta_ky, 0],
            [delta_ky, delta_kx, -1],
            [0, 0, 0]])
        psi[k] = H[k] @ sigma_predicted @ H[k].T + np.eye(z_state) @ Q

    # Update
    mu_updated = mu_predicted.copy() # final state etsimate holder

    # Accumulate Kalman gain times residual matrix
    residual_gain_sum = np.zeros_like(mu_predicted)

    # Accumulate Kalman gain times observation matrix
    KH_sum = np.zeros_like(sigma_predicted)

    for z_observed in zs:
        # Maximum Likelihood Correspondence
        ji = []
        for k in range(n_map_points):
            z_residual = z_observed - z_expected[k]
            psi_k = psi[k]
            likelihood = z_residual.T @ np.linalg.inv(psi_k) @ z_residual
            ji.append(likelihood)

        i = ji.index(min(ji)) # find the index of the minimum chi-square distance
        K_i = sigma_predicted @ H[i].T @ np.linalg.inv(psi[i])
        z_associated = z_expected[i]

        residual_gain_sum += + K_i @ (z_observed - z_associated)
        KH_sum += K_i @ H[i]
    
    # Final state and covariance update
    sigma_updated = (np.eye(x_state) - KH_sum) @ sigma_predicted
    mu_updated = mu_predicted + residual_gain_sum

    return mu_updated, sigma_updated

